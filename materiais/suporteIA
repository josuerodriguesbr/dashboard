////////// LAYOUTS DINAMICOS //////////////////////
**Conceito geral: Layout Din√¢mico com Inje√ß√£o de Conte√∫do (Template Engine Simples)**

Esse arquivo `layout.php` √© um **template mestre** que:

1. **Define a estrutura base** do HTML (cabe√ßalho, corpo, rodap√©, CSS/JS globais).
2. **Recebe vari√°veis din√¢micas** (`$title`, `$content`, `$inline_css`, `$page_js`, etc.) de p√°ginas filhas.
3. **Injeta conte√∫do din√¢mico** no local certo (`<?= $content ?>`).
4. **Permite personaliza√ß√£o por p√°gina** (CSS/JS inline ou externos).
5. **Reutiliza c√≥digo** ‚Äî evita repeti√ß√£o de HTML/CSS/JS em todas as p√°ginas.

üëâ Funciona como um **molde** ‚Äî cada p√°gina preenche as lacunas (`$content`, etc.) e o layout monta o HTML final.

‚úÖ Separa√ß√£o de responsabilidades  
‚úÖ Manuten√ß√£o facilitada  
‚úÖ Consist√™ncia visual e funcional

√â o conceito b√°sico por tr√°s de **MVC (View)** e frameworks como Laravel (Blade), mas feito manualmente com PHP puro.



//////////////////// JWT DEMO LOCALSTORAGE ////////////////////
Eu estava usando o Qwen para fazer esse projeto, mas ele empancou numa quest√£o e n√£o deu mais certo. Ent√£o fui para o Gemini e levei o c√≥digo atual, o c√≥digo que o Qwen at√© ent√£o conseguiu gerar.
Mostrei o c√≥digo para o gemini e ele rapidamente conseguiu resolver, aqui n√£o temos o c√≥digo que enviei para o gemini, mas j√° que ele devolveu um c√≥digo funcional, isso √© o que importa e vou doculmentar a partir do c√≥digo que ele devolveu.

...

Ol√°! Analisei o seu c√≥digo e o problema √© muito interessante e comum em aplica√ß√µes de p√°gina √∫nica como essa. A l√≥gica est√° quase correta, mas h√° um pequeno erro de fluxo que causa exatamente o comportamento que voc√™ descreveu.
Vou explicar o problema e depois fornecer o c√≥digo corrigido.

O Problema: O Fluxo de Requisi√ß√£o e Resposta

A√ß√£o do Usu√°rio: Voc√™ preenche o nome e a senha e clica em "Cadastrar / Entrar".
JavaScript (fetch): Seu JavaScript corretamente envia os dados via fetch com o m√©todo POST para o pr√≥prio jwt-demo.php.
PHP (Backend): O PHP recebe o POST com nome e senha. Ele processa o login/cadastro, gera um novo JWT ($jwt) e monta a p√°gina HTML completa do usu√°rio logado (com o bot√£o "Logout").
Resposta para o fetch: O PHP envia essa p√°gina HTML completa de volta como resposta para a chamada fetch.
JavaScript (o ponto crucial): Aqui est√° o erro. O seu c√≥digo JavaScript faz o fetch, mas ignora completamente a resposta do servidor. Logo ap√≥s iniciar o fetch, ele executa a linha:
JavaScript
window.location.reload();


Recarregamento: O navegador obedece e recarrega a p√°gina. Esse recarregamento √© uma requisi√ß√£o GET completamente nova, sem nenhum dado de POST.
PHP (2¬™ Execu√ß√£o): O PHP executa novamente, mas como √© um GET e n√£o h√° token na URL, ele n√£o encontra nenhum usu√°rio ($user fica null) e, portanto, renderiza o formul√°rio de login novamente.
Em suma: o token at√© √© gerado e enviado na resposta do fetch, mas seu JavaScript joga essa resposta fora e recarrega a p√°gina antes de ter a chance de salvar o novo token no localStorage.

A Solu√ß√£o

A solu√ß√£o √© fazer o PHP se comportar de duas maneiras:
Requisi√ß√£o normal (GET): Se for uma requisi√ß√£o normal, ele envia a p√°gina HTML completa.
Requisi√ß√£o de login (POST via fetch): Se for uma requisi√ß√£o para fazer login, em vez de enviar a p√°gina HTML, ele deve enviar apenas os dados importantes em formato JSON (por exemplo: { "success": true, "token": "seu_novo_token" }).
O JavaScript, por sua vez, deve esperar por essa resposta JSON, extrair o token, salv√°-lo no localStorage e S√ì ENT√ÉO recarregar a p√°gina.

C√≥digo Corrigido e Comentado

Aqui est√° a vers√£o corrigida do seu arquivo jwt-demo.php. As principais altera√ß√µes est√£o marcadas com // ALTERADO ou // NOVO.

PHP


<?php
// jwt-demo.php - Demonstra√ß√£o simples de JWT com PHP + localStorage

// --- CONFIGURA√á√ÉO E FUN√á√ïES ---
define('ROOT', __DIR__ . '/');
// Crie este arquivo com define('JWT_SECRET', 'sua-chave-secreta-muito-longa');
require_once ROOT . 'config/jwt-secret.php';

$usuariosFile = ROOT . 'usuarios.json';

// Cria arquivo se n√£o existir
if (!file_exists($usuariosFile)) {
    file_put_contents($usuariosFile, json_encode([]));
}

// Fun√ß√µes JWT (Implementa√ß√£o de exemplo)
function base64url_encode($data) {
    return rtrim(strtr(base64_encode($data), '+/', '-_'), '=');
}

function base64url_decode($data) {
    return base64_decode(str_pad(strtr($data, '-_', '+/'), strlen($data) % 4, '=', STR_PAD_RIGHT));
}

function jwt_encode($payload) {
    $header = json_encode(['typ' => 'JWT', 'alg' => 'HS256']);
    // Adiciona tempo de expira√ß√£o de 20 minutos
    $payload['exp'] = time() + (20 * 60);
    $payload = json_encode($payload);

    $base64UrlHeader = base64url_encode($header);
    $base64UrlPayload = base64url_encode($payload);

    $signature = hash_hmac('sha256', $base64UrlHeader . "." . $base64UrlPayload, JWT_SECRET, true);
    $base64UrlSignature = base64url_encode($signature);

    return $base64UrlHeader . "." . $base64UrlPayload . "." . $base64UrlSignature;
}

function jwt_decode($token) {
    $parts = explode('.', $token);
    if (count($parts) !== 3) return null;

    list($base64UrlHeader, $base64UrlPayload, $base64UrlSignature) = $parts;
    
    $signature = base64url_decode($base64UrlSignature);
    $expectedSignature = hash_hmac('sha256', $base64UrlHeader . "." . $base64UrlPayload, JWT_SECRET, true);

    if (!hash_equals($expectedSignature, $signature)) {
        return null; // Assinatura inv√°lida
    }

    $payload = json_decode(base64url_decode($base64UrlPayload), true);

    // Verifica se o token expirou
    if (isset($payload['exp']) && $payload['exp'] < time()) {
        return null; // Token expirado
    }

    return $payload;
}
// --- FIM DAS FUN√á√ïES ---


// Carrega usu√°rios do arquivo
$usuarios = json_decode(file_get_contents($usuariosFile), true) ?? [];

$user = null;

// Resetar tudo
if (isset($_POST['reset'])) {
    @unlink($usuariosFile);
    // Para requisi√ß√µes fetch, apenas retornamos sucesso.
    if (!empty($_SERVER['HTTP_X_REQUESTED_WITH']) && strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) == 'xmlhttprequest') {
        echo json_encode(['success' => true]);
        exit;
    }
    header('Location: ' . $_SERVER['PHP_SELF']);
    exit;
}

// NOVO: L√≥gica para tratar a submiss√£o do formul√°rio de login via fetch/AJAX
if ($_SERVER['REQUEST_METHOD'] === 'POST' && isset($_POST['action']) && $_POST['action'] === 'login') {
    header('Content-Type: application/json');
    $nome = $_POST['nome'] ?? '';
    $senha = $_POST['senha'] ?? '';
    $foundUser = null;

    if ($nome && $senha) {
        if (!empty($usuarios)) {
            // L√≥gica de login: procura o usu√°rio
            // ALTERADO: Itera sobre os usu√°rios em vez de checar apenas o primeiro
            foreach ($usuarios as $u) {
                if ($u['nome'] === $nome && $u['senha'] === $senha) {
                    $foundUser = ['nome' => $u['nome'], 'nivel' => $u['nivel']];
                    break;
                }
            }
        } else {
            // Primeiro cadastro
            $novoUsuario = [
                'nome' => $nome,
                'senha' => $senha,
                'nivel' => 'usuario',
                'criado' => date('Y-m-d H:i:s')
            ];
            file_put_contents($usuariosFile, json_encode([$novoUsuario]));
            $foundUser = ['nome' => $novoUsuario['nome'], 'nivel' => $novoUsuario['nivel']];
        }
    }
    
    if ($foundUser) {
        $jwt = jwt_encode($foundUser);
        echo json_encode(['success' => true, 'token' => $jwt]);
    } else {
        echo json_encode(['success' => false, 'message' => 'Nome ou senha inv√°lidos.']);
    }
    exit; // Termina o script aqui para n√£o enviar o HTML
}


// --- L√ìGICA PARA CARREGAMENTO DA P√ÅGINA (GET) ---

// 1. Tenta pelo token na URL (enviado pelo JS para verifica√ß√£o)
$token = $_GET['verify_token'] ?? null;
if ($token) {
    $user = jwt_decode($token);
}

// Se o usu√°rio foi autenticado, gera um novo token (renova a expira√ß√£o)
$jwt = $user ? jwt_encode($user) : null;

?>
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo JWT Simples</title>
    <style>/* Seu CSS aqui (sem altera√ß√µes) */</style>
</head>
<body>
    <div class="container" id="app">
        <?php if ($user && $jwt): ?>
            <h2>üîê Logado como: <?= htmlspecialchars($user['nome']) ?></h2>
            <p class="info">Token v√°lido por 20 minutos</p>
            <button class="logout-btn" onclick="logout()">Logout</button>
            <button class="reset-btn" onclick="resetAll()">Resetar Tudo</button>
            <p><small>Token: <code><?= htmlspecialchars($jwt) ?></code></small></p>
        <?php else: ?>
            <h2>üìù Cadastro / Login</h2>
            <form id="loginForm">
                <input type="text" id="nome" placeholder="Seu nome" required>
                <input type="password" id="senha" placeholder="Senha" required>
                <button type="submit">Cadastrar / Entrar</button>
                <div id="errorMessage" class="error" style="margin-top: 10px;"></div>
            </form>
            <button class="reset-btn" onclick="resetAll()">Resetar Tudo</button>
        <?php endif; ?>
    </div>

<script>
    // Se a p√°gina foi carregada com um usu√°rio logado, salva/atualiza o token.
    <?php if ($jwt): ?>
    console.log("üîê Token v√°lido, salvando no localStorage:", '<?= addslashes($jwt) ?>');
    localStorage.setItem('authToken', '<?= addslashes($jwt) ?>');
    <?php endif; ?>

    // Tenta autenticar via localStorage ao carregar a p√°gina
    window.onload = () => {
        // Se j√° existe um bot√£o de logout, significa que o PHP j√° renderizou a p√°gina logada. N√£o faz nada.
        if (document.querySelector('.logout-btn')) {
            return;
        }

        const token = localStorage.getItem('authToken');
        if (token) {
            console.log("üîé Encontrado token no localStorage, verificando...");
            // Redireciona para a URL com o token para verifica√ß√£o no backend
            window.location.href = `?verify_token=${encodeURIComponent(token)}`;
        }
    };

    // ALTERADO: L√≥gica de submit do formul√°rio de login
    document.getElementById('loginForm')?.addEventListener('submit', async (e) => {
        e.preventDefault();
        const nome = document.getElementById('nome').value;
        const senha = document.getElementById('senha').value;
        const errorMessageDiv = document.getElementById('errorMessage');
        errorMessageDiv.textContent = ''; // Limpa erros antigos

        const formData = new FormData();
        formData.append('action', 'login'); // NOVO: envia uma a√ß√£o para o PHP saber o que fazer
        formData.append('nome', nome);
        formData.append('senha', senha);

        try {
            const response = await fetch('', { // Envia para a pr√≥pria p√°gina
                method: 'POST',
                body: formData
            });

            const data = await response.json(); // Espera uma resposta JSON

            if (data.success && data.token) {
                // SUCESSO! Salva o token e recarrega a p√°gina
                console.log("‚úÖ Login bem-sucedido, token recebido:", data.token);
                localStorage.setItem('authToken', data.token);
                window.location.reload(); // Agora sim, recarrega!
            } else {
                // FALHA! Mostra a mensagem de erro
                errorMessageDiv.textContent = data.message || 'Ocorreu um erro.';
                console.error("‚ùå Falha no login:", data.message);
            }
        } catch (error) {
            errorMessageDiv.textContent = 'Erro de comunica√ß√£o com o servidor.';
            console.error("üí• Erro no fetch:", error);
        }
    });

    function logout() {
        console.log("üöÄ Saindo...");
        localStorage.removeItem('authToken');
        // Redireciona para a p√°gina limpa, sem o token na URL
        window.location.href = window.location.pathname;
    }

    function resetAll() {
        if (confirm('Tem certeza que quer resetar tudo?')) {
            localStorage.removeItem('authToken');
            const formData = new FormData();
            formData.append('reset', '1');
            fetch('', {
                method: 'POST',
                body: formData
            }).then(() => {
                window.location.href = window.location.pathname;
            });
        }
    }
</script>

</body>
</html>



Resumo das Mudan√ßas Principais:

PHP:
Adicionei uma implementa√ß√£o b√°sica das suas fun√ß√µes JWT, incluindo expira√ß√£o de 20 minutos.
Criei um bloco if no in√≠cio que intercepta POST com action=login. Esse bloco retorna JSON e d√° um exit;, impedindo que o resto do HTML seja renderizado nessas requisi√ß√µes.
A l√≥gica de carregamento da p√°gina agora s√≥ precisa se preocupar com requisi√ß√µes GET que tentam verificar um token pela URL.
Corrigi a l√≥gica para carregar o array $usuarios no in√≠cio do script.
Melhorei a busca de usu√°rio para percorrer o array em vez de verificar apenas o primeiro elemento.
JavaScript:
O submit do formul√°rio agora envia action=login no FormData.
A fun√ß√£o fetch agora processa a resposta. Ela espera um JSON (response.json()).
Se a resposta for de sucesso (data.success), ele salva o data.token no localStorage e s√≥ ent√£o chama window.location.reload().
Se falhar, ele exibe uma mensagem de erro para o usu√°rio.
A l√≥gica do window.onload foi simplificada: se n√£o estou logado mas tenho um token, apenas redireciono para a URL de verifica√ß√£o. Isso unifica o fluxo de autentica√ß√£o.
Agora seu c√≥digo deve funcionar como o esperado: ao se cadastrar/logar, o token ser√° salvo corretamente e a p√°gina recarregar√° para o estado "logado".

Deu um probleminha:
Est√° acontecendo o seguinte, quando passa os 20 minutos e eu atualizo a p√°gina, fica como se tivesse num loop infinito. Fica recarregando indefinidamente.

Excelente observa√ß√£o\! Voc√™ encontrou um excelente caso de borda e um bug de l√≥gica cl√°ssico em fluxos de autentica√ß√£o com token. O seu racioc√≠nio est√° correto, o problema √© exatamente o que acontece quando o token expira.

O loop infinito acontece pelo seguinte motivo:

1.  **P√°gina Atualiza:** Voc√™ atualiza a p√°gina (F5).
2.  **`window.onload` Executa:** O JavaScript √© executado. Ele encontra o token **expirado** no `localStorage`. Para o JavaScript, ele √© apenas um texto, n√£o h√° como saber que expirou ainda.
3.  **Verifica√ß√£o no Servidor:** O script ent√£o redireciona para a URL `?verify_token=...`, enviando o token expirado para o PHP.
4.  **PHP Rejeita o Token:** O PHP recebe o token, a fun√ß√£o `jwt_decode` verifica o tempo de expira√ß√£o (`$payload['exp'] < time()`) e, como o token expirou, retorna `null`.
5.  **Renderiza Login:** Como `$user` √© `null`, o PHP renderiza a p√°gina de login.
6.  **O Ciclo Recome√ßa:** O navegador carrega essa nova p√°gina de login. O script `window.onload` dela executa novamente. Ele olha no `localStorage` e encontra **o mesmo token expirado** (porque nada o removeu). Ele ent√£o redireciona para a verifica√ß√£o... e volta para o passo 3, criando um loop infinito de recarregamento.

### A Solu√ß√£o

A solu√ß√£o √© fazer com que o servidor, ao identificar que um token de verifica√ß√£o √© inv√°lido (seja por expira√ß√£o ou assinatura incorreta), **instrua o navegador a limpar o token ruim do `localStorage`**.

Faremos isso adicionando um pequeno script na p√°gina de login que s√≥ ser√° impresso se a p√°gina estiver sendo renderizada por causa de uma falha na verifica√ß√£o do token.

### Altera√ß√µes no C√≥digo

Voc√™ s√≥ precisa fazer duas pequenas altera√ß√µes no seu arquivo `jwt-demo.php`.

**1. No topo, na se√ß√£o de l√≥gica PHP, modifique o bloco de verifica√ß√£o do token:**

Vamos adicionar uma vari√°vel `$token_invalido` para sabermos quando a falha ocorreu.

```php
// --- L√ìGICA PARA CARREGAMENTO DA P√ÅGINA (GET) ---

// 1. Tenta pelo token na URL (enviado pelo JS para verifica√ß√£o)
$token = $_GET['verify_token'] ?? null;
$token_invalido = false; // NOVO: Flag para token inv√°lido

if ($token) {
    $user = jwt_decode($token);
    if (!$user) { // ALTERADO: Se a decodifica√ß√£o falhar (expirado, inv√°lido)...
        $token_invalido = true; // ...marcamos a flag.
    }
}

// Se o usu√°rio foi autenticado, gera um novo token (renova a expira√ß√£o)
$jwt = $user ? jwt_encode($user) : null;
```

**2. No final do arquivo, logo antes da tag `<script>` principal, adicione este bloco PHP:**

Este bloco ir√° gerar o c√≥digo JavaScript para limpar o `localStorage` apenas quando a nossa flag `$token_invalido` for verdadeira.

```html
        <?php endif; ?>
    </div>

<?php if ($token_invalido): ?>
<script>
    console.error("Token de verifica√ß√£o inv√°lido ou expirado. Limpando o localStorage.");
    localStorage.removeItem('authToken');
</script>
<?php endif; ?>

<script>
    // Se a p√°gina foi carregada com um usu√°rio logado, salva/atualiza o token.
    <?php if ($jwt): ?>
    console.log("üîê Token v√°lido, salvando no localStorage:", '<?= addslashes($jwt) ?>');
// ... (o resto do seu script continua igual)
```

### Como o Loop √© Quebrado Agora

Com essas altera√ß√µes, o fluxo se torna:

1.  **P√°gina Atualiza:** Voc√™ atualiza a p√°gina com o token expirado no `localStorage`.
2.  **`window.onload` Executa:** O JavaScript redireciona para `?verify_token=...`.
3.  **PHP Rejeita e Marca:** O PHP v√™ que o token expirou, define `$user` como `null` e `$token_invalido` como `true`.
4.  **Renderiza Login + Script de Limpeza:** O PHP renderiza a p√°gina de login E tamb√©m o pequeno script: `<script>localStorage.removeItem('authToken');</script>`.
5.  **Navegador Executa:** O navegador carrega a p√°gina de login. O script de limpeza √© executado imediatamente e **remove o token expirado** do `localStorage`.
6.  **`window.onload` Executa (sem token):** Agora, quando o script principal (`window.onload`) for executado, `localStorage.getItem('authToken')` retornar√° `null`. A condi√ß√£o `if (token)` ser√° falsa.
7.  **Fim do Loop:** Nenhum redirecionamento ocorrer√°. A p√°gina de login ser√° exibida corretamente, e o loop infinito √© evitado.

Essa √© uma forma robusta e simples de garantir que o estado do cliente (`localStorage`) e do servidor permane√ßam sincronizados.

Ol√°\! Excelente feedback, a sua descri√ß√£o do problema foi perfeita e ajudou a identificar a causa raiz do novo comportamento.

Voc√™ est√° quase l√°\! O que est√° acontecendo √© uma "corrida" entre o token novo que voc√™ acabou de receber e o token antigo que ainda est√° na URL.

Vamos analisar o fluxo exato:

1.  **Estado Inicial:** Ap√≥s o token expirar, a p√°gina recarrega e a URL fica "suja", por exemplo: `.../jwt-demo.php?verify_token=TOKEN_EXPIRADO`. O `localStorage` foi corretamente limpo pela corre√ß√£o que fizemos. Voc√™ v√™ o formul√°rio de login.

2.  **Novo Cadastro:** Voc√™ preenche um novo usu√°rio e senha e clica em "Cadastrar / Entrar".

3.  **Requisi√ß√£o `fetch` (Sucesso):** O JavaScript envia a requisi√ß√£o `POST` para a URL atual (`...?verify_token=TOKEN_EXPIRADO`). O PHP ignora a parte do `verify_token` (pois est√° tratando um `POST` com `action=login`), processa o cadastro, cria um **novo token v√°lido** e retorna `{ success: true, token: "NOVO_TOKEN_VALIDO" }`.

4.  **JavaScript Recebe o Sucesso:** O seu c√≥digo no `addEventListener` recebe a resposta.

      * `data.success` √© `true`.
      * `localStorage.setItem('authToken', 'NOVO_TOKEN_VALIDO')` √© executado. **Neste momento, o token correto est√° salvo\!**
      * Em seguida, `window.location.reload()` √© executado.

5.  **O Pulo do Gato (O Erro):** `window.location.reload()` recarrega a URL **exata** que est√° na barra de endere√ßo, que ainda √© `.../jwt-demo.php?verify_token=TOKEN_EXPIRADO`.

6.  **Recarregamento da P√°gina "Suja":** O PHP agora recebe uma requisi√ß√£o `GET` para essa URL com o token expirado.

      * Ele executa a l√≥gica de verifica√ß√£o: `jwt_decode('TOKEN_EXPIRADO')` falha.
      * A nossa flag `$token_invalido` √© setada para `true`.
      * O PHP renderiza a p√°gina de login e, crucialmente, tamb√©m renderiza o script de limpeza: `<script>localStorage.removeItem('authToken');</script>`.

7.  **Limpeza Indevida:** Esse script de limpeza √© executado e **apaga o `NOVO_TOKEN_VALIDO`** que voc√™ tinha acabado de salvar no passo 4.

O resultado final √© que voc√™ volta para a tela de login com o `localStorage` limpo, como se o login nunca tivesse acontecido.

### A Solu√ß√£o: Redirecionar para uma URL Limpa

A corre√ß√£o √© muito simples. Em vez de simplesmente recarregar a p√°gina atual, precisamos redirecionar o navegador para uma URL "limpa", sem nenhum par√¢metro.

Altere apenas uma linha no seu JavaScript, dentro do `addEventListener` do formul√°rio.

**Substitua isto:**

```javascript
// DENTRO DO addEventListener('submit', ...)
if (data.success && data.token) {
    // SUCESSO! Salva o token e recarrega a p√°gina
    console.log("‚úÖ Login bem-sucedido, token recebido:", data.token);
    localStorage.setItem('authToken', data.token);
    window.location.reload(); // <--- PROBLEMA EST√Å AQUI
} else {
// ...
```

**Por isto:**

```javascript
// DENTRO DO addEventListener('submit', ...)
if (data.success && data.token) {
    // SUCESSO! Salva o token e recarrega a p√°gina
    console.log("‚úÖ Login bem-sucedido, token recebido:", data.token);
    localStorage.setItem('authToken', data.token);
    // ALTERADO: Redireciona para a URL base (limpa)
    window.location.href = window.location.pathname; 
} else {
// ...
```

`window.location.pathname` pega o caminho do arquivo no servidor (ex: `/jwt-demo.php`) sem nenhum par√¢metro de query string (`?verify_token=...`).

Com essa mudan√ßa, o fluxo ap√≥s o login bem-sucedido ser√°:

1.  O `NOVO_TOKEN_VALIDO` √© salvo no `localStorage`.
2.  O navegador √© redirecionado para `.../jwt-demo.php` (URL limpa).
3.  A p√°gina limpa carrega, e o script `window.onload` √© executado.
4.  Ele encontra o `NOVO_TOKEN_VALIDO` no `localStorage`.
5.  Ele redireciona para a verifica√ß√£o: `.../jwt-demo.php?verify_token=NOVO_TOKEN_VALIDO`.
6.  O PHP valida o token com sucesso e exibe a p√°gina de usu√°rio logado.

Problema resolvido\!


//////////////////////////// NOVO CONTEXTO ///////////////////////////////

Depois eu pedi para o gimini converter o c√≥digo que estava usando localStorage para usar cookies HttpOnly, o que √© mais seguro. Aqui est√° o c√≥digo atualizado com cookies HttpOnly:

D√° pra fazer uma vers√£o para usar cooke sem modificar o c√≥digo b√°sico?

Com certeza\! √â uma √≥tima ideia usar cookies, especialmente cookies `HttpOnly`, pois eles aumentam a seguran√ßa da sua aplica√ß√£o ao impedir que o token seja acessado por scripts maliciosos no lado do cliente (ataques XSS).

A melhor parte √© que a l√≥gica b√°sica de gerar e decodificar o JWT permanece exatamente a mesma. O que muda √© como o token √© **transportado e armazenado**. Em vez de o JavaScript salvar no `localStorage` e enviar manualmente, o navegador far√° isso de forma autom√°tica e segura.

O "c√≥digo b√°sico" (suas fun√ß√µes JWT e a l√≥gica de verifica√ß√£o de usu√°rio/senha) n√£o ser√° modificado. Vamos apenas alterar a "camada de transporte" do token.

Aqui est√° a vers√£o adaptada do seu c√≥digo para usar cookies.

### Principais Diferen√ßas Conceituais

1.  **Servidor Define o Cookie:** Ap√≥s o login, o PHP usar√° a fun√ß√£o `setcookie()` para enviar o token ao navegador. O navegador o armazenar√° automaticamente.
2.  **Navegador Envia o Cookie:** Em cada requisi√ß√£o subsequente ao seu site (como recarregar a p√°gina), o navegador enviar√° o cookie de volta para o PHP automaticamente.
3.  **PHP L√™ o Cookie:** O PHP n√£o precisar√° mais procurar o token em `$_GET['verify_token']`. Ele simplesmente o ler√° da vari√°vel superglobal `$_COOKIE`.
4.  **JavaScript Simplificado:** O JavaScript n√£o precisa mais manipular o token. O `window.onload` para verifica√ß√£o se torna desnecess√°rio, pois o PHP j√° saber√° se o usu√°rio est√° logado ou n√£o na primeira carga da p√°gina.

-----

### C√≥digo Modificado para Usar Cookies

```php
<?php
// jwt-demo-cookie.php - Vers√£o com Cookie HttpOnly

// --- CONFIGURA√á√ÉO E FUN√á√ïES JWT (Id√™nticas √† vers√£o anterior) ---
define('ROOT', __DIR__ . '/');
require_once ROOT . 'config/jwt-secret.php';

$usuariosFile = ROOT . 'usuarios.json';
if (!file_exists($usuariosFile)) file_put_contents($usuariosFile, json_encode([]));

// Fun√ß√µes JWT (base64url_encode, jwt_encode, etc.) s√£o as mesmas...
function base64url_encode($data) { /* ... */ }
function base64url_decode($data) { /* ... */ }
function jwt_encode($payload) { /* ... */ }
function jwt_decode($token) { /* ... */ }

// --- FIM DAS FUN√á√ïES ---

$usuarios = json_decode(file_get_contents($usuariosFile), true) ?? [];
$user = null;
$action = $_POST['action'] ?? '';

// --- L√ìGICA DE A√á√ïES (POST) ---

// Resetar tudo
if (isset($_POST['reset'])) {
    @unlink($usuariosFile);
    // Limpa o cookie de autentica√ß√£o ao resetar
    setcookie('authToken', '', time() - 3600, '/', '', false, true);
    header('Location: ' . $_SERVER['PHP_SELF']);
    exit;
}

// A√ß√£o de Login
if ($_SERVER['REQUEST_METHOD'] === 'POST' && $action === 'login') {
    header('Content-Type: application/json');
    $nome = $_POST['nome'] ?? '';
    $senha = $_POST['senha'] ?? '';
    $foundUser = null;

    // L√≥gica de encontrar/criar usu√°rio (id√™ntica √† anterior)
    if ($nome && $senha) {
        if (!empty($usuarios)) {
            foreach ($usuarios as $u) {
                if ($u['nome'] === $nome && $u['senha'] === $senha) {
                    $foundUser = ['nome' => $u['nome'], 'nivel' => $u['nivel']];
                    break;
                }
            }
        } else {
            $novoUsuario = ['nome' => $nome, 'senha' => $senha, 'nivel' => 'usuario', 'criado' => date('Y-m-d H:i:s')];
            file_put_contents($usuariosFile, json_encode([$novoUsuario]));
            $foundUser = ['nome' => $novoUsuario['nome'], 'nivel' => $novoUsuario['nivel']];
        }
    }
    
    if ($foundUser) {
        $jwt = jwt_encode($foundUser);
        $cookie_expiration = time() + (20 * 60); // 20 minutos
        
        // ALTERADO: Em vez de enviar token no JSON, definimos um cookie HttpOnly
        setcookie('authToken', $jwt, [
            'expires' => $cookie_expiration,
            'path' => '/',
            // 'domain' => '.seusite.com', // Descomente e ajuste se necess√°rio
            'secure' => false, // Mude para true se estiver usando HTTPS
            'httponly' => true, // Essencial: o cookie n√£o pode ser acessado por JS
            'samesite' => 'Lax' // Prote√ß√£o contra CSRF
        ]);
        
        // Apenas informamos ao JS que o login foi um sucesso
        echo json_encode(['success' => true]);
    } else {
        echo json_encode(['success' => false, 'message' => 'Nome ou senha inv√°lidos.']);
    }
    exit;
}

// NOVO: A√ß√£o de Logout
if ($_SERVER['REQUEST_METHOD'] === 'POST' && $action === 'logout') {
    header('Content-Type: application/json');
    // Para "deletar" um cookie, o definimos com um tempo de expira√ß√£o no passado.
    setcookie('authToken', '', time() - 3600, '/', '', false, true);
    echo json_encode(['success' => true]);
    exit;
}

// --- L√ìGICA PARA CARREGAMENTO DA P√ÅGINA (GET) ---

// ALTERADO: A verifica√ß√£o agora √© feita diretamente pelo cookie enviado pelo navegador.
// N√£o precisamos mais de `verify_token` na URL.
if (isset($_COOKIE['authToken'])) {
    $user = jwt_decode($_COOKIE['authToken']);
}

// Se o usu√°rio foi autenticado, geramos um novo token para renovar o tempo de expira√ß√£o do cookie.
if ($user) {
    $jwt = jwt_encode($user);
    setcookie('authToken', $jwt, [ 'expires' => time() + (20 * 60), 'path' => '/', 'secure' => false, 'httponly' => true, 'samesite' => 'Lax' ]);
} else {
    $jwt = null; // Garante que o token n√£o seja exibido se o cookie for inv√°lido
}

?>
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    </head>
<body>
    <div class="container" id="app">
        <?php if ($user && $jwt): ?>
            <h2>üîê Logado como: <?= htmlspecialchars($user['nome']) ?> (Cookie)</h2>
            <p class="info">Sess√£o v√°lida por 20 minutos</p>
            <button class="logout-btn" onclick="logout()">Logout</button>
            <button class="reset-btn" onclick="resetAll()">Resetar Tudo</button>
            <p><small>Token est√° em um cookie HttpOnly e n√£o pode ser lido via JS.</small></p>
        <?php else: ?>
            <h2>üìù Cadastro / Login (Cookie)</h2>
            <form id="loginForm">
                <input type="text" id="nome" placeholder="Seu nome" required>
                <input type="password" id="senha" placeholder="Senha" required>
                <button type="submit">Cadastrar / Entrar</button>
                <div id="errorMessage" class="error" style="margin-top: 10px;"></div>
            </form>
            <button class="reset-btn" onclick="resetAll()">Resetar Tudo</button>
        <?php endif; ?>
    </div>

<script>
    // REMOVIDO: Toda a l√≥gica de `window.onload` para verificar token √© desnecess√°ria.
    // O PHP j√° sabe se o usu√°rio est√° logado ou n√£o quando a p√°gina √© constru√≠da.

    // L√≥gica de submit do formul√°rio de login
    document.getElementById('loginForm')?.addEventListener('submit', async (e) => {
        e.preventDefault();
        const nome = document.getElementById('nome').value;
        const senha = document.getElementById('senha').value;
        const errorMessageDiv = document.getElementById('errorMessage');
        errorMessageDiv.textContent = '';

        const formData = new FormData();
        formData.append('action', 'login');
        formData.append('nome', nome);
        formData.append('senha', senha);

        try {
            const response = await fetch('', { method: 'POST', body: formData });
            const data = await response.json();

            // ALTERADO: N√£o precisamos mais receber e salvar o token.
            // Apenas verificamos se o login deu certo e recarregamos a p√°gina.
            // O navegador j√° recebeu e salvou o cookie.
            if (data.success) {
                window.location.href = window.location.pathname; // Recarrega para uma URL limpa
            } else {
                errorMessageDiv.textContent = data.message || 'Ocorreu um erro.';
            }
        } catch (error) {
            errorMessageDiv.textContent = 'Erro de comunica√ß√£o com o servidor.';
        }
    });

    // ALTERADO: Fun√ß√£o de logout agora chama o backend para limpar o cookie.
    async function logout() {
        console.log("üöÄ Saindo...");
        const formData = new FormData();
        formData.append('action', 'logout');
        
        await fetch('', { method: 'POST', body: formData });
        
        // Ap√≥s o backend limpar o cookie, redirecionamos.
        window.location.href = window.location.pathname;
    }

    // Fun√ß√£o de reset (praticamente a mesma, s√≥ mudamos o corpo do POST)
    function resetAll() {
        if (confirm('Tem certeza que quer resetar tudo?')) {
            const formData = new FormData();
            formData.append('reset', '1');
            fetch('', {
                method: 'POST',
                body: formData
            }).then(() => {
                window.location.href = window.location.pathname;
            });
        }
    }
</script>

</body>
</html>
```

### Resumo das Mudan√ßas e Vantagens

  * **PHP:**
      * **Login:** Usa `setcookie()` para criar o cookie `authToken` com as flags `HttpOnly` e `SameSite=Lax`.
      * **Logout:** Adicionamos uma nova `action=logout` que usa `setcookie()` com data no passado para apagar o cookie.
      * **Verifica√ß√£o:** A checagem de sess√£o na carga da p√°gina √© feita lendo `$_COOKIE['authToken']` em vez de `$_GET['verify_token']`.
  * **JavaScript:**
      * **C√≥digo Removido:** A fun√ß√£o `window.onload` foi completamente removida. O c√≥digo fica mais limpo e o "flash" da p√°gina de login antes de logar desaparece.
      * **Login:** O `fetch` de login n√£o espera mais um token de volta, apenas uma confirma√ß√£o de sucesso.
      * **Logout:** A fun√ß√£o `logout()` agora faz uma requisi√ß√£o `POST` ao backend para que o PHP possa destruir o cookie.

Esta abordagem √© considerada **mais segura e robusta** para aplica√ß√µes web do que o armazenamento de tokens em `localStorage`.

